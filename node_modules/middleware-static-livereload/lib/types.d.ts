/// <reference types="node" />
import * as fs from 'fs';
import * as stream from 'stream';
import * as http from 'http';
import * as util from 'util';
import * as chokidar from 'chokidar';
import { LogLevel } from './LogLevel';
export interface ILog {
    (...args: Array<any>): void;
}
export interface IConsole {
    debug: ILog;
    info: ILog;
    error: ILog;
    logLevel: LogLevel;
    stdout: NodeJS.WritableStream;
    stderr: NodeJS.WritableStream;
}
export interface IFile {
    path: string;
    relativePath: string;
    stats: fs.Stats;
}
export interface IFileFinder {
    documentRoots: Array<string>;
    isReserved: (file: string) => boolean;
    (pathname: string): Promise<IFile>;
}
export interface IContentTypeGetter {
    (pathname: string): string | null;
}
export interface ISnippetInjector {
    size: number;
    (readable: stream.Readable): stream.Transform;
}
export interface IEventCompiler {
    (data: string, eventName?: string): string;
}
export interface ISendEvent {
    (...args: Parameters<IEventCompiler>): void;
}
export interface IConnectionHandler {
    sendEvent: ISendEvent;
    (req: http.IncomingMessage, res: http.ServerResponse): void;
}
export interface IOptions {
    documentRoot?: string | Array<string>;
    watch?: chokidar.WatchOptions | chokidar.FSWatcher | boolean | null;
    index?: string;
    contentTypes?: Record<string, string | Array<string>>;
    logLevel?: LogLevel;
    stdout?: NodeJS.WritableStream;
    stderr?: NodeJS.WritableStream;
    insertBefore?: string | RegExp | Array<string | RegExp>;
    insertAfter?: string | RegExp | Array<string | RegExp>;
    scriptPath?: string;
    encoding?: BufferEncoding;
    inspectOptions?: util.InspectOptions;
}
export interface IServerResponseLike {
    end: http.ServerResponse['end'];
    statusCode?: http.ServerResponse['statusCode'];
    headersSent?: http.ServerResponse['headersSent'];
    writableEnded?: http.ServerResponse['writableEnded'];
}
